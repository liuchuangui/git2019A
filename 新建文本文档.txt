git中每一个版本包含全部文件

执行git init生成git管理目录.git
删除 rm -rf .git

已修改（modified）
已暂存（staged)
已提交（commited)

工作区---------->暂存区
  (use "git add <file>..." to include in what will be committed)
暂存区---------->工作区
  (use "git rm --cached <file>..." to unstage)


git log
commit b5e9febef5437674aa932cdc3c590d94fec35acf（一个随机数，分布式id生成器，用于区分是那一次的提交（并且不重复）)

git log -2
最近两次提交

$ git log --pretty=oneline
显示id和备注

$ git log --pretty=format:"%h--%ar:%s"
自定义格式

设置邮箱和用户名 
    --global              给当前计算机一次性设置
    --system              给当前用户一次性设置，推荐使用
    --local  		给当前项目一次性设置

设置用户名
$ git config --local user.name "张三"
设置邮箱
$ git config --local user.email "3313995600@qq.com"
查看 git config

当前用户的配置
.gitconfig文件中

$ git commit -m "我的提交测试1"


还原修改：$ git checkout -- hello.txt

从暂存区到工作区
  (use "git restore --staged <file>..." to unstage)


ls


删除对象区的一个文件
$ git rm b.txt------>文件被修改到暂存区
$ git commit -m "彻底删除b.txt" ---->工作区和暂存区都删除

操作系统删除和rm有什么不同
操作系统删除：操作在工作区
rm删除：操作在暂存区


重命名：mv
原文件和重命名后的新文件


重写注释：$ git commit --amend -m "ssssssssss"



忽略文件：.gitignore
touch .gitignore
	在会略文件中使用通配符
		*.properties
		!c.propertie忽略以.properties结尾的文件但是不包含c.properties
		dir:/    忽略dir文件夹中的所有文件
		dir/*.txt
		dir/*/*.txt中间包含一级目录
		dir/**/*.txt 中间包含任意级目录
	空目录默认就是忽略的
	
	
	
创建新分支：
	$ git branch：查看分支
	$ git branch new_branch：创建分支
	$ git checkout -b testC：创建分支
	$ git checkout new_branch：切换分支
     $ git branch -d new_branch：删除分支
		分支存在未合并的分支不能删除


创建并切换分支：


合并分支：merge

强行删除分支：$ git branch -D testC

在testA分支中的工作区和暂存区的内容在master分支中通过git status可以看到，但是testA分支的对象区的内容通过master分支的git status不能发现
commit后的内容不能直接删除，commit前的内容可以直接删除


快照：每一次提交后的说有文件
	包含：sha1值，parent(第一次提交的时候没有，是上一次提交的sha1值)


分支是一个commit链，一条工作记录线


分支名（master）：指向当前的提交（commit）
HEAD:指向当前分支（HEAD--》分支名）


如果两个分支一个靠前，一个靠后，且不冲突，直接通过merge后缀可以追上前者
fast forward：两个分支fast forward归于一点
fast forward：丢失分支信息

也可以使用no fast forward保存分支信息
$ git merge --no-ff demoA
	不丢失分支信息 $ git log --graph




版本穿梭：在多个commit之间穿梭，回退，前进

合并add 和commit
git commit -am "注释"
回退上一次 git reset --hard HEAD^  (一个^代表回退一次，两个代表回退两次)
回退上10次 git reset --hard HEAD~10
回退到前任意次：git reset --hard sha1值  

git reflog保存了所有的记录



checkout：放弃修改:放弃的是相对于暂存区或对象区
reset:将之前添加到暂存区的内容回退到工作区

git checkout sha1值
版本穿梭（游离状体）
		1，修改后，必须提交
		2，创建分支的好时机
		3，创建分支 git branch testB 1232424


stash：保存现场
	1，建议：没功能没有开发完毕前，不要commit,
	2，规定：在没有commit之前，不能checkout切换分支(分支在不同的时刻)
临时保存（保存现场）
	$ git stash
查看现场：$ git stash list

恢复保存的临时文件并删除：
	$ git stash pop
恢复保存的临时文件不删除
	$ git stash apply
	手工删除现场：git stash drop stash@{0}

	如何两个分支在同一个commit阶段，在commit之前可以切换分支


标签：tag     适用于整个项目，和分支没有关系
$ git tag v2.0 
$ git tag -a v2.0 -m "标签名"
查看标签：
git tag
删除标签：
$ git tag -d v1.0



blame：责任
	$ git blame a.txt
diff：差异性 比较文件的差异
	$ diff a.txt b.txt
	$ diff -u a.txt b.txt
git diff commit的sha1值 比较对象区和工作区的差异

git diff --cached commit的sha1值 比较对象区和暂存区的差异


push:推到远程
pull:拉到本地



gitHub



推送：
$ git remote add origin https://github.com/liuchuangui/git2019.git
以后使用origin就代表使用https://github.com/liuchuangui/git2019.git  


$ git push

使用HTTPS协议需要密码
使用ssh 免密码登陆
	本地放私钥，远程放公钥
密码生成
	$ ssh-keygen
github中可以把公钥放在项目中也可以放在账户中 1，删除回车符，2，勾选可写框


dev分支：开发分支，频繁改变
test分支：测试分支，交给测试实施人员的分支
master：生成阶段，很少变化
bugfix:临时修改bug分支

$ git remote show
查看当前项目有几个远程服务器

git回在本地维护一个 origin/master分支(这是一个分支)，通过该分支感知远程的内容


$ git branch -av
查看本地分支和远程分支是否同步


克隆一个远程项目
$ git clone git@github.com:liuchuangui/git2019A.git
$ git clone git@github.com:liuchuangui/git2019A.git testSSSSSS





push和pull除了可以拉代码，还可以改变指针

push前要先pull

pull=fetch+merge


在命令行输入gipk会出现图形化操作工具

第一次提交dev分支的内容
	git push -u origin dev
第一次提交test分支的内容
	git push --set-upstream origin test


远程------》本地
	1,pull :远程--》追踪分支
	2,追踪--》本地分支
		方法一：git checkout -b dev origin/dev
		方法二：git checkout -b test --track origin/test
		      git checkout --track origin/test



删除本地分支：git branch -D test
删除远程分支：1，通过网页删除
           2,git push origin  :test
           3,git push origin --delete test

git push orign div:test   把本地div分支推送到远程test分支


本地没有dev分支，但是本地感知dev分支，删除本地dev感知分支
检测分支：git remote prune origin --dry-run
清理无效分支：git remote prune origin


git gc:压缩文件


git裸库：没有工作区，工作仓库，存在于服务器


submodule:子模块
	在一个仓库中引用另外一个仓库的内容



rebase：变基（衍合）：改变分支的根基
	编写代码的地方

B-->A  在B中操作
git rebase 转移的分支名

rebase会改变提交线路，rebase之后会变成一根线

rebase也有冲突， 
	a,解决冲突后
		git add .
		git rebase --continue
		git merge 另外一个分支
	b,忽略冲突（放弃rebase所在分支的修改，直接使用其他分支）
		git rebase --skip





























